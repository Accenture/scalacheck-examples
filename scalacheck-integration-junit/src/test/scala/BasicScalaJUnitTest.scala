package com.company.junit

import org.junit.Assert._
import org.junit.Test
import com.company.scalacheck.Rectangle
import org.scalacheck.Test.Params
import org.scalacheck.{ConsoleReporter, Prop, Properties, Arbitrary, Gen, Test => SchkTest}
import org.scalacheck.Prop._

/**
 * Generator of case objects for the Rectangle class, as well as an arbitrary generator
 */
object RectangleGenerator {
  // generator for the Rectangle case class
  val rectangleGen: Gen[Rectangle] = for {
    height <- Gen.choose(0, 9999)
    width <- Gen.choose(0, 9999)
  } yield (Rectangle(width, height))

  // Arbitrary generator of rectangles
  implicit val arbRectangle: Arbitrary[Rectangle] = Arbitrary(rectangleGen)
}

class ScalaJUnitSimpleTest {
  val validProperty = Prop.forAll { (a:String) =>
    (a.length > 0) ==> (a + a == a.concat(a))
  }  
  
  @Test def testSquareRoot = {
    assertTrue(SchkTest.check(Params(testCallback = ConsoleReporter()), validProperty).passed)
  }
}

/**
 * This is an example of a JUnit test case implemented in Scala, where the actual testing logic is implemented
 * as ScalaCheck property checks that are evaluated with JUnit's assertTrue assertion. Each one of the test
 * cases is implemented with a different approach, up until the last one that uses an implicit function to allow
 * to provide Prop objects (as generated by Prop.forAll) to JUnit's assertTrue
 *
 * The ScalaCheck property checks are regular properties that use an arbitrary generator.
 *
 * The only kind of integration visible here is through the doCheck method, that is able to execute a property check
 * and return true or false depending on the result reported by ScalaCheck; the returned value is then suitable to
 * be provided to assertTrue to report success or failure to JUnit
 */
class ScalaJUnitTest {

  import RectangleGenerator._

  @Test def simpleTest = {
    val r = Rectangle(4, 5)
    assertTrue("Area does not match", r.areaCorrect == (4 * 5))
  }

  /**
   * Two properties for our testing purposes. The first one fails, while
   * the second one holds true
   */
  val failedTest = Prop.forAll { (r: Rectangle) =>
    r.area == (r.height * r.width)
  }
  val validTest = Prop.forAll { (r: Rectangle) =>
    r.areaCorrect == (r.height * r.width)
  }

  /**
   * This property should not hold, and it should be reported as a JUnit assertion failure
   */
  @Test def testWithFailedPropertyCheck = {
     assertTrue(doCheck(failedTest))
  }

  /**
   * This property check holds true, and it should show as a successful test execution in JUnit
   */
  @Test def testWithValidPropertyCheck = {
    assertTrue(doCheck(validTest))
  }

  /**
   * With this implicit conversion we can pass a Prop object (such as the result of a Prop.forAll call) to
   * JUnit's assertTrue
   */
  implicit def doCheck(p: Prop): Boolean = SchkTest.check(Params(testCallback = ConsoleReporter()), p).passed

  @Test def testWithImplicitConversion = {
    assertTrue(validTest)
  }
}

